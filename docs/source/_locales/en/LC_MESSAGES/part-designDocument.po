# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, ECNU-SE-lab
# This file is distributed under the same license as the Kea package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Kea 1.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-12-30 19:40+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: en\n"
"Language-Team: en <LL@li.org>\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.16.0\n"

#: ../source/part-designDocument/InputGenerator/InputManager.rst:2
msgid "InputManager"
msgstr ""

#: ../source/part-designDocument/InputGenerator/InputManager.rst:4
msgid "本部分旨在解释 Kea 的中的策略及输入控制器类 InputManager 的设计与实现。"
msgstr "This section aims to explain the design and implementation of the strategy and the input controller class InputManager in Kea."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:8
#: ../source/part-designDocument/kea/kea.rst:7
#: ../source/part-designDocument/kea/keaTestElements.rst:7
#: ../source/part-designDocument/user-interface/keaTest-suite/kea-test.rst:7
msgid "功能设计与实现"
msgstr "Functional Design and Implementation"


#: ../source/part-designDocument/InputGenerator/InputManager.rst:10
msgid ""
"InputManager类是事件生成器的控制类，负责启动、停止事件的生成， "
"并负责根据指定的输入策略生成和发送事件，支持随机探索策略、主路径引导策略和LLM策略。 "
"该类提供了灵活的事件管理机制，允许用户自定义事件生成策略，并能够根据应用的运行状态动态调整事件发送。 InputManager所包含的主要方法有："
msgstr ""
"The InputManager class is the control class for the event generator, responsible for starting and stopping event generation, "
"as well as generating and sending events based on specified input strategies, supporting random exploration strategy, main path guiding strategy, and LLM strategy. "
"This class provides a flexible event management mechanism, allowing users to customize event generation strategies and dynamically adjust event sending based on the application's runtime state. The main methods included in InputManager are:"

#: ../source/part-designDocument/InputGenerator/InputManager.rst:15
msgid "获取当前测试用户所选择的探索策略。"
msgstr "Get the exploration strategy selected by the current test user."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:16
msgid "添加事件到设备的执行事件列表等待执行。"
msgstr "Add events to the device's execution event list for execution."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:17
msgid "使用当前探索策略开始生成事件进行测试。"
msgstr "Start generating events for testing using the current exploration strategy."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:18
msgid "停止生成事件，结束此次测试。"
msgstr "Stop generating events, ending this test."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:23
msgid "InputManager 类的组成"
msgstr "Composition of the InputManager Class"

#: ../source/part-designDocument/InputGenerator/InputManager.rst:27
#: ../source/part-designDocument/InputGenerator/MainPath
#: ../source/part-designDocument/stateful_testing/Bundle.rst:43 Guided
#: Policy.rst:201
msgid "为了便于读者理解，本文中提供的代码段简化版本仅对核心流程进行抽象并展示，实际代码与简化的参考代码不完全一致。"
msgstr "To facilitate readers' understanding, the code snippets provided in this article are simplified versions that only abstract and display the core processes; the actual code is not completely consistent with the simplified reference code."


#: ../source/part-designDocument/InputGenerator/InputManager.rst:30
msgid "类属性"
msgstr "Class attributes"

#: ../source/part-designDocument/InputGenerator/InputManager.rst:32
msgid "``DEFAULT_POLICY``: 默认的输入策略名称。"
msgstr "``DEFAULT_POLICY``: The default input strategy name."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:33
msgid "``RANDOM_POLICY``: 随机输入策略名称。"
msgstr "``RANDOM_POLICY``: The random input strategy name."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:34
msgid "``DEFAULT_EVENT_INTERVAL``: 默认事件间隔时间。"
msgstr "``DEFAULT_EVENT_INTERVAL``: The default event interval time."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:35
msgid "``DEFAULT_EVENT_COUNT``: 默认生成事件的数量。"
msgstr "``DEFAULT_EVENT_COUNT``: The default number of events to generate."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:36
msgid "``DEFAULT_TIMEOUT``: 默认超时时间。"
msgstr "``DEFAULT_TIMEOUT``: The default timeout duration."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:37
msgid "``DEFAULT_DEVICE_SERIAL``: 默认设备序列号。"
msgstr "``DEFAULT_DEVICE_SERIAL``: The default device serial number."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:38
msgid "``DEFAULT_UI_TARPIT_NUM``: 默认UI陷阱数量。"
msgstr "``DEFAULT_UI_TARPIT_NUM``: The default number of UI tar pits."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:41
msgid "InputManager类中的数据结构"
msgstr "Data structures in the InputManager class"

#: ../source/part-designDocument/InputGenerator/InputManager.rst:43
msgid "**device**"
msgstr ""

#: ../source/part-designDocument/InputGenerator/InputManager.rst:45
msgid "device是Device的对象，用于记录当前测试的设备信息,便于后续对设备的交互操作。"
msgstr "The device is an object of the Device class, used to record the information of the currently tested device, facilitating subsequent interactions with the device."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:47
msgid "**app**"
msgstr ""

#: ../source/part-designDocument/InputGenerator/InputManager.rst:49
msgid "app是App的对象，用于记录当前所测试的移动应用的信息。"
msgstr "The app is an object of the App class, used to record information about the mobile application currently being tested."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:51
msgid "**policy & policy_name**"
msgstr ""

#: ../source/part-designDocument/InputGenerator/InputManager.rst:53
msgid "policy_name是string类型，用于存储用户所选择的探索策略名。policy是具体探索策略类的对象。"
msgstr "policy_name is a string type used to store the name of the exploration strategy selected by the user. policy is an object of the specific exploration strategy class."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:55
msgid "**event_count & event_interval & number_of_events_that_restart_app**"
msgstr ""

#: ../source/part-designDocument/InputGenerator/InputManager.rst:57
msgid ""
"这三个成员变量均为整型。event_count记录从测试开始到现在生成的事件个数；event_interval记录了用户设置的两个事件之间停顿的时间；"
" number_of_events_that_restart_app为多少个事件后需要重启应用程序。"
msgstr ""
"These three member variables are all of integer type. event_count records the number of events generated from the start of the test until now; event_interval records the time set by the user between two events; "
"number_of_events_that_restart_app indicates how many events must occur before restarting the application."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:60
msgid "**kea**"
msgstr "**kea**"

#: ../source/part-designDocument/InputGenerator/InputManager.rst:62
msgid "kea为Kea类的对象，用于生成事件过程中从Kea类中取出记录数据来完成对应用性质的测试。"
msgstr "kea is an object of the Kea class, used to extract recorded data from the Kea class during the event generation process to complete the testing of application properties."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:64
msgid "**enabled**"
msgstr "**enabled**"

#: ../source/part-designDocument/InputGenerator/InputManager.rst:66
msgid "enabled为bool类型，用于记录当前事件生成器是否需要继续生成事件，默认值为True。"
msgstr "enabled is of boolean type, used to indicate whether the current event generator should continue generating events, with a default value of True."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:68
msgid "**generate_utg**"
msgstr "**generate_utg**"

#: ../source/part-designDocument/InputGenerator/InputManager.rst:70
msgid "enerate_utg为bool类型用于记录用户所设置的是否生成UI转移图的参数，便于生成事件的过程中判断是否应该生成UI转移图。"
msgstr "generate_utg is a boolean type used to record whether the user has set the parameter to generate the UI transition graph, facilitating the decision of whether to generate the UI transition graph during event generation."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:72
msgid "**sim_caculator**"
msgstr "**sim_caculator**"

#: ../source/part-designDocument/InputGenerator/InputManager.rst:74
msgid "sim_caculator为Similarity的对象，用于计算上一个界面状态与当前界面状态之间的相似性。"
msgstr "sim_caculator is an object of the Similarity class, used to calculate the similarity between the previous interface state and the current interface state."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:77
msgid "InputManager类中的成员方法"
msgstr "Member methods in the InputManager class"

#: ../source/part-designDocument/InputGenerator/InputManager.rst:80
msgid "构造函数"
msgstr "Constructor"

#: ../source/part-designDocument/InputGenerator/InputManager.rst:82
msgid "``__init__`` 方法用于初始化InputManager实例，设置事件发送的基本参数，并根据提供的策略名称初始化对应的输入策略。"
msgstr "The ``__init__`` method initializes the InputManager instance, sets the basic parameters for event sending, and initializes the corresponding input strategy based on the provided strategy name."

#: ../source/part-designDocument/InputGenerator/InputManager.rst
#: ../source/part-designDocument/InputGenerator/MainPath
#: ../source/part-designDocument/InputGenerator/llm.rst
#: ../source/part-designDocument/InputGenerator/random.rst
#: ../source/part-designDocument/kea/kea.rst
#: ../source/part-designDocument/kea/keaTestElements.rst
#: ../source/part-designDocument/stateful_testing/Bundle.rst
#: ../source/part-designDocument/user-interface/keaTest-suite/decorators.rst
#: Guided Policy.rst
msgid "参数"
msgstr "Parameters"

#: ../source/part-designDocument/InputGenerator/InputManager.rst:85
msgid "``device``: Device实例，表示目标设备。"
msgstr "``device``: Device instance, representing the target device."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:86
msgid "``app``: App实例，表示目标应用。"
msgstr "``app``: App instance, representing the target application."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:87
msgid "``policy_name``: 字符串，指定生成事件的策略名称。"
msgstr "``policy_name``: String, specifying the name of the strategy for generating events."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:88
msgid "``random_input``: 布尔值，指示是否使用随机输入。"
msgstr "``random_input``: Boolean value indicating whether to use random input."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:89
msgid "``event_interval``: 事件间隔时间。"
msgstr "``event_interval``: Event interval time."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:90
msgid "``event_count``: 事件生成数量，默认为``DEFAULT_EVENT_COUNT``。"
msgstr "``event_count``: Number of events to generate, defaulting to ``DEFAULT_EVENT_COUNT``."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:91
msgid "``profiling_method``: 分析方法，用于性能分析。"
msgstr "``profiling_method``: Analysis method used for performance profiling."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:92
msgid "``kea``: Kea实例，用于性质测试。"
msgstr "``kea``: Kea instance used for property testing."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:93
msgid "``number_of_events_that_restart_app``: 重启应用的事件数量。"
msgstr "``number_of_events_that_restart_app``: Number of events after which the application needs to be restarted."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:94
msgid "``generate_utg``: 布尔值，指示是否生成UTG。"
msgstr "``generate_utg``: Boolean value indicating whether to generate the UTG."

#: ../source/part-designDocument/InputGenerator/InputManager.rst
#: ../source/part-designDocument/InputGenerator/llm.rst
#: ../source/part-designDocument/InputGenerator/random.rst
msgid "核心流程"
msgstr "Core Process"

#: ../source/part-designDocument/InputGenerator/InputManager.rst:97
msgid "初始化日志记录器。"
msgstr "Initialize the logger."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:98
msgid "设置事件发送参数。"
msgstr "Set event sending parameters."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:99
msgid "根据策略名称初始化输入策略。"
msgstr "Initialize the input strategy based on the strategy name."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:100
msgid "设置相似度计算器。"
msgstr "Set the similarity calculator."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:103
msgid "获取探索策略的方法"
msgstr "Method to get the exploration strategy"

#: ../source/part-designDocument/InputGenerator/InputManager.rst:105
msgid "**get_input_policy**"
msgstr "**get_input_policy**"

#: ../source/part-designDocument/InputGenerator/InputManager.rst:107
msgid ""
"get_input_policy 方法根据用户所选择的policy_name来实例化对应的探索策略对象。 "
"实例化的对象存储在policy成员变量里。支持的策略包括：随机探索策略、主路径引导策略和LLM策略。"
msgstr ""
"The get_input_policy method instantiates the corresponding exploration strategy object based on the policy_name selected by the user. "
"The instantiated object is stored in the policy member variable. Supported strategies include: random exploration strategy, main path guiding strategy, and LLM strategy."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:111
msgid "``device``: Device实例。"
msgstr "``device``: Device instance."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:112
msgid "``app``: App实例。"
msgstr "``app``: App instance."

#: ../source/part-designDocument/InputGenerator/InputManager.rst
#: ../source/part-designDocument/InputGenerator/MainPath
#: ../source/part-designDocument/InputGenerator/llm.rst
#: ../source/part-designDocument/InputGenerator/random.rst
#: ../source/part-designDocument/kea/kea.rst
#: ../source/part-designDocument/kea/keaTestElements.rst
#: ../source/part-designDocument/stateful_testing/Bundle.rst
#: ../source/part-designDocument/user-interface/keaTest-suite/decorators.rst
#: Guided Policy.rst
msgid "返回"
msgstr "Return"

#: ../source/part-designDocument/InputGenerator/InputManager.rst:115
msgid "本次测试使用的策略实例。"
msgstr "The strategy instance used for this test."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:118
msgid "根据策略名称判断使用哪种输入策略。"
msgstr "Determine which input strategy to use based on the strategy name."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:119
msgid "创建对应的输入策略实例。"
msgstr "Create the corresponding input strategy instance."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:137
msgid "事件生成器的控制方法"
msgstr "Control methods of the event generator"

#: ../source/part-designDocument/InputGenerator/InputManager.rst:139
#: ../source/part-designDocument/InputGenerator/llm.rst:249
msgid "**start**"
msgstr "**start**"

#: ../source/part-designDocument/InputGenerator/InputManager.rst:141
msgid "start 方法用于启动所选定的探索策略。"
msgstr "The start method is used to initiate the selected exploration strategy."


#: ../source/part-designDocument/InputGenerator/InputManager.rst:144
msgid "记录开始发送事件的日志。"
msgstr "Log the start of event sending."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:145
msgid "根据输入策略开始发送事件。"
msgstr "Start sending events according to the input strategy."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:146
msgid "处理键盘中断，确保优雅退出。"
msgstr "Handle keyboard interrupts to ensure a graceful exit."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:158
msgid "**stop**"
msgstr ""

#: ../source/part-designDocument/InputGenerator/InputManager.rst:160
msgid "stop 方法用于结束探索过程。"
msgstr "The stop method is used to end the exploration process."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:163
msgid "终止事件发送。"
msgstr "Terminate event sending."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:164
msgid "清理事件发送相关的资源。"
msgstr "Clean up resources related to event sending."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:165
msgid "记录停止发送事件的日志。"
msgstr "Log the stop of event sending."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:172
msgid "**add_event**"
msgstr ""

#: ../source/part-designDocument/InputGenerator/InputManager.rst:174
msgid "add_event添加一个事件到事件列表，并将该事件发送给移动设备。"
msgstr "The add_event method adds an event to the event list and sends it to the mobile device."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:177
msgid "``event``: 要添加的事件，应为AppEvent的子类。"
msgstr "``event``: The event to be added, which should be a subclass of AppEvent."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:180
msgid "将事件添加到事件列表。"
msgstr "Add the event to the event list."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:181
msgid "创建事件日志记录器。"
msgstr "Create an event logging mechanism."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:182
msgid "根据事件间隔时间发送事件到设备。"
msgstr "Send events to the device based on the event interval time."

#: ../source/part-designDocument/InputGenerator/InputManager.rst:199
msgid "使用方法"
msgstr "Usage"

#: ../source/part-designDocument/InputGenerator/InputManager.rst:201
msgid ""
"InputManager类的主要作用是控制事件生成器并管理应用运行期间的事件发送。 "
"用户可以通过构造函数初始化InputManager实例，并设置相应的参数，如测试设备、被测应用、策略名称等。 "
"然后，可以通过start方法启动事件生成器。通过add_event方法添加单个事件，并发送。通过stop方法停止生成事件。"
msgstr ""
"The main role of the InputManager class is to control the event generator and manage event sending during the application's runtime. "
"Users can initialize the InputManager instance through the constructor and set the corresponding parameters, such as the test device, the application under test, and the strategy name. "
"Then, the event generator can be started using the start method. Individual events can be added and sent using the add_event method. The stop method is used to stop event generation."

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:4
msgid "GuidedPolicy"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:6
msgid ""
"GuidedPolicy类是主路径引导探索策略的核心类。 主要负责获取用户在定义性质时定义的主路径以及根据主路径引导探索策略生成输入事件。 "
"该类提供了完整的主路径引导探索策略的事件生成过程引导方法。 GuidedPolicy所包含的主要方法有："
msgstr ""
"The GuidedPolicy class is the core class of the main path guiding exploration strategy. It is primarily responsible for obtaining the main path defined by the user when defining properties and generating input events based on the main path guiding exploration strategy. "
"This class provides a complete guiding method for the event generation process of the main path guiding exploration strategy. The main methods included in GuidedPolicy are:"

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:11
msgid "开始一段测试前从用户定义的主路径中随机选择一条主路径。"
msgstr "Randomly select a main path from the user-defined main paths before starting a test."

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:12
msgid "根据当前状态是否在主路径上决定返回事件种类。"
msgstr "Determine the type of return event based on whether the current state is on the main path."

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:13
msgid "在主路径上获取下一个执行的事件。"
msgstr "Get the next event to execute on the main path."

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:14
msgid "离开主路径探索应用深层状态过程的主要调控。"
msgstr "The main control process for exploring the application's deeper states outside the main path."

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:15
msgid "从主路径上获取能引导应用回到主路径上的事件。"
msgstr "Obtain events from the main path that can guide the application back to the main path."

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:19
msgid "主路径引导策略的介绍"
msgstr "Introduction to the main path guiding strategy"

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:21
msgid ""
"据观察，当用户指定应用程序性质时，用户通常沿着应用程序入口的主路径到达目标应用程序功能。这样的主要路径可以很容易地作为获得，并能够用于指导探索。 "
"具体来说，当从应用程序入口执行主路径时，我们可以获得一系列GUI状态 :math:`S = [s_0,s_1,s_2,……,s_n]`, 其中 "
":math:`s_n \\models P`， 即 :math:`s_n` "
"满足前置条件。此外，探索靠近主路径的状态可能会有更高的机会达到满足前提条件的 GUI 状态。本算法的核心执行流程如图。"
msgstr ""
"It has been observed that when users specify the properties of an application, they typically follow the main path from the application entry to reach the target application functionality. Such main paths can be easily obtained and used to guide exploration. "
"Specifically, when executing the main path from the application entry, we can obtain a series of GUI states :math:`S = [s_0,s_1,s_2,……,s_n]`, where "
":math:`s_n \\models P`, meaning that :math:`s_n` "
"satisfies the preconditions. Furthermore, exploring states close to the main path may have a higher chance of reaching GUI states that satisfy the preconditions. The core execution flow of this algorithm is illustrated in the figure."

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:28
msgid "主路径引导探索策略的流程图"
msgstr "Flowchart of the main path guiding exploration strategy"

#: ../source/part-designDocument/InputGenerator/MainPath
#: ../source/part-designDocument/InputGenerator/llm.rst:26
#: ../source/part-designDocument/InputGenerator/random.rst:27
#: ../source/part-designDocument/user-interface/cli/cli.rst:18 Guided
#: Policy.rst:30
msgid "具体执行步骤如下："
msgstr "The specific execution steps are as follows:"

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:32
msgid ""
"步骤1：将主路径中的每个事件 :math: `e_i` 发送到被测移动应用，得到主路径的状态序列 :math:`S = "
"[s_0,s_1,s_2,……,s_n]`， 从而使被测移动应用到达满足前置条件 :math:`P` 的状态 :math:`s_n`;"
msgstr ""
"Step 1: Send each event :math: `e_i` in the main path to the mobile application under test, obtaining the state sequence of the main path :math:`S = "
"[s_0,s_1,s_2,……,s_n]`, thus allowing the mobile application to reach the state :math:`s_n` that satisfies the precondition :math:`P`;"

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:35
msgid ""
"步骤2：判断是否达到最大测试执行时间，若达到则结束测试，否则按照 :math:`S = [s_0,s_1,s_2,……,s_n]` "
"倒序探索应用程序。 若 :math:`S` 中的所有状态被探索完毕，则初始化被测移动应用；否则，按倒序关系取出一个未被探索的状态 "
":math:`s_i`， 发送相应的前序事件序列 :math:`[e_1,e_2,……，e_i]`,使得被测移动应用到达主路径状态 "
":math:`s_i`,继续步骤3；"
msgstr ""
"Step 2: Determine whether the maximum test execution time has been reached. If so, end the test; otherwise, explore the application in reverse order according to :math:`S = [s_0,s_1,s_2,……,s_n]`. "
"If all states in :math:`S` have been explored, initialize the mobile application under test; otherwise, retrieve an unexplored state :math:`s_i` in reverse order, send the corresponding preceding event sequence :math:`[e_1,e_2,……，e_i]`, allowing the mobile application to reach the main path state :math:`s_i`, and continue to Step 3;"

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:39
msgid ""
"步骤3：以状态 :math:`s_i` 作为探索被测移动应用的起始状态，判断当前已执行事件个数是否达到最大执行事件个数， "
"如没有达到，获取当前被测移动应用状态，继续步骤4；如果达到，则执行6；"
msgstr ""
"Step 3: Use state :math:`s_i` as the starting state for exploring the mobile application under test. Determine whether the current number of executed events has reached the maximum number of events. "
"If not, obtain the current state of the mobile application under test and continue to Step 4; if so, proceed to Step 6;"

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:42
msgid ""
"步骤4：判断当前被测移动应用状态是否满足一个或多个前置条件 :math:`P`。若没有任何前置条件满足或者不进行性质检测， "
"则继续执行步骤5；否则，执行交互场景 :math:`I` 中定义的事件序列，判断后置条件 :math:`Q` 是否满足，返回步骤3；"
msgstr ""
"Step 4: Determine whether the current state of the mobile application under test satisfies one or more preconditions :math:`P`. If no preconditions are satisfied or if property checking is not performed, "
"continue to Step 5; otherwise, execute the event sequence defined in the interaction scenario :math:`I`, check whether the postcondition :math:`Q` is satisfied, and return to Step 3;"

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:45
msgid "步骤5：使用外部用户界面交互工具分析当前界面状态获取可执行事件列表，从可以执行的事件列表中随机选择一项事件， 并发送给被测移动应用执行，返回步骤3；"
msgstr "Step 5: Use external user interface interaction tools to analyze the current interface state and obtain a list of executable events. Randomly select an event from the executable event list and send it to the mobile application under test for execution, then return to Step 3;"


#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:48
msgid "步骤6：判断当前状态能否转换为状态 :math:`s_n`，若能，则发送相应的事件到被测移动应用，使得移动应用的状态满足前置条件；"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:50
msgid "为了更清晰的展示该策略的上述过程，在此通过下图进一步详析这一过程。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:55
msgid "主路径引导探索策略的实施例示意图"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:57
msgid ""
"令 :math:`s_0` 为被测移动应用的起始探索状态，主路径为 :math:`E = [e_1,e_2,e_3,e_4]`，性质为 "
":math:`\\phi = <P,I,Q>`。 在第一次迭代中，该策略将发送 :math: `E` 的所有事件并到达 :math:`s_4` "
"并且 :math:`s_4 \\models P`。 满足 :math:`P` 的状态用灰色标记。然后本策略引导从 :math:`s_4` "
"开始随机探索。假设它在 :math:`s_4` 上生成 :math:`e_5` 并达到 :math:`s_5`。 假设 :math:`s_5 "
"\\models P`，策略可能决定执行 :math:`I` 获得结束状态 :math:`s_6` 并在该状态上检查后置条件 :math:`Q`。"
" 假设 :math:`s_6 \\models P`，则说明没有发现性质错误。此时，假设 :math:`e_5` 和 :math:`I` "
"的执行事件数量超过预先限定的最大事件数量， 策略将停止随机探索并尝试导航到满足 :math:`P` 的主路径。假设 :math:`E` "
"中的事件无法在 :math:`s_6` 上发送，则该策略会放弃引导过程，并开始第二次迭代。 在第二次和第三次迭代中，它将分别从 "
":math:`s_3` 和 :math:`s_2` 开始，并执行与第一次迭代类似的过程。在第 4 次迭代中，从 :math:`s_1` 开始。 "
"假设过程中通过生成两个随机事件 :math:`e_6` 和 :math:`e_7` 来探索 :math:`s_1`，:math:`e_6 \\to"
" s_7`，:math:`e_7 \\to s_8`， 但 :math:`s_7` 和 :math:`s_8` 都不满足前置条件 "
":math:`P`，则本策略尝试导航回遵循满足 :math:`P` 的主路径。假设过程中发现 :math:`e_3` 可以在 "
":math:`s_8` 上发送。它会依次发送 :math:`e_3` 和 :math:`e_4` 以尝试遵循主路径。假设最终到达满足 "
":math:`P` 的 :math:`s_4` 本策略将执行 :math:`I` 并在结束状态 :math:`s_9` 上检查后置条件 "
":math:`Q`。如果后置条件不成立，则表明发现一个功能性质错误。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:69
msgid "步骤7：检查当前状态是否满足前置条件，若满足则进行性质测试；"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:71
msgid "步骤8：重启移动应用并返回步骤2。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:74
msgid "默认参数"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:76
msgid "``MAX_NUM_RESTARTS``: 最大重启次数。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:77
msgid "``MAX_NUM_STEPS_OUTSIDE``: 应用外的最大步骤数。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:78
msgid "``MAX_NUM_STEPS_OUTSIDE_KILL``: 应用外最大步骤数（强制终止）。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:79
msgid "``START_TO_GENERATE_EVENT_IN_POLICY``: 策略中生成事件的起始时间。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:80
msgid "``MAX_NUM_QUERY_LLM``: 最大查询 LLM 的次数。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:81
msgid "``EVENT_FLAG_STARTED``: 事件开始标志。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:82
msgid "``EVENT_FLAG_START_APP``: 启动应用的事件标志。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:83
msgid "``EVENT_FLAG_STOP_APP``: 停止应用的事件标志。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:84
msgid "``EVENT_FLAG_EXPLORE``: 探索事件标志。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:85
msgid "``EVENT_FLAG_NAVIGATE``: 导航事件标志。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:86
msgid "``EVENT_FLAG_TOUCH``: 触摸事件标志。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:87
msgid "``POLICY_GUIDED``: 主路径引导策略名称。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:88
msgid "``POLICY_RANDOM``: 随机策略名称。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:89
msgid "``POLICY_LLM``: LLM 策略名称。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:90
msgid "``POLICY_NONE``: 无策略名称。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:93
msgid "GuidedPolicy类中的数据结构"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:95
msgid "**main_path**"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:97
msgid "main_path是MainPath类的对象，是当前测试过程所选用的主路径。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:99
msgid "**execute_main_path**"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:101
msgid "execute_main_path为bool类型，用于记录当前界面状态是否在主路径上。用于根据不同情况生成不同事件。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:103
msgid "**current_index_on_main_path**"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:105
msgid "current_index_on_main_path整型，为当前所处主路径的事件节点编号。初始值为0。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:107
msgid "**current_number_of_mutate_steps_on_single_node**"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:109
msgid "current_number_of_mutate_steps_on_single_node整型，记录了已经在当前状态节点上探索生成事件的次数。初始值为0。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:111
msgid "**max_number_of_mutate_steps_on_single_node**"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:113
msgid "max_number_of_mutate_steps_on_single_node整型，记录了对单个状态节点最大探索生成事件的次数。初始值为20。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:115
msgid "**number_of_events_that_try_to_find_event_on_main_path**"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:117
msgid "number_of_events_that_try_to_find_event_on_main_path整型，记录了当前尝试回到主路径的次数。初始值为0。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:119
msgid "**index_on_main_path_after_mutation**"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:121
msgid "index_on_main_path_after_mutation整型，是对某个状态节点执行一系列事件探索后能够回到的主路径上的事件编号。初始值为-1。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:123
msgid "**mutate_node_index_on_main_path**"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:125
msgid "mutate_node_index_on_main_path整型，是记录当前所探索的主路径上的事件节点编号。初始值为所选主路径的长度。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:128
msgid "主路径引导策略的伪代码"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:130
msgid ":math:`\\textbf{Algorithm:} Main Path Guided Exploration`"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:132
msgid ":math:`\\textbf{Input:} \\phi = <P,I,Q>,E=[e_1,e_2,……,e_n]`"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath
#: ../source/part-designDocument/InputGenerator/llm.rst:79 Guided
#: Policy.rst:134
msgid ":math:`\\textbf{Output:} Bug Report`"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:177
msgid ""
"此策略采用输入一个性质 :math:`\\phi = <P,I,Q>` 和事件序列 :math:`E = [e_1,e_2,……,e_n]` "
"形式的主路径。 该策略沿主路径向后遍历，并在接近主路径的范围内进行UI探索（第 3-12 行）。具体来说， 它从 :math:`e_n` "
"向后迭代到 :math:`e_1` （第 8 行）。对于 :math:`0 < i \\leq n` 的每个事件 :math:`e_i`, "
"它会将前缀 :math:`[e_1,e_2,……,e_i]` 发送到应用程序，以达到主路径的 GUI 状态 :math:`s_i` （第 5-6 "
"行）。 接下来，它探索接近 :math:`s_i` 的 GUI 状态，尝试找到满足前置条件 :math:`P` 的状态（第 7 行）。请注意， 在"
" :math:`s_1` 之后，本系统还通过不从 :math:`E` 发送任何事件来探索接近 :math:`s_0` 的 GUI 状态（第 4 "
"行）。 如果时间预算允许，可以沿主路径进行多次遍历，我们在探索主路径上的每个状态（第 9-11 行）后清理应用程序数据。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:185
msgid ""
"从主路径的 GUI 状态开始的探索类似于前述随机探索策略（第 14-20 行）。具体来说，在每个 GUI 状态中， 本算法检查是否满足某个前置条件"
" :math:`P` （第 15-16 行）。如果有前置条件满足，本算法会有50%的概率来测试 :math:`s` 处的性质（第 16 "
"行）。否则，将生成随机事件并发送给设备以达到另一个状态（第 19-20 行）。 上述过程迭代 :math:`MAX_STEP` 次（第 14 "
"行）。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:190
msgid ""
"探索完之后，本算法尝试回到满足前提条件的状态（第 21-23 行）。因为从主路径的 GUI 状态开始的随机探索可能会改变应用程序的内部状态， "
"在这种情况下，达到满足前置条件的状态可能会进一步表现出不同的行为。为此， 本算法搜索可在当前 GUI 状态（第 28-32 行）发送的最接近事件 "
":math:`e_j`。如果 :math:`e_j` 存在， 我们尝试给设备发送发送 :math:`E` 的后缀 "
":math:`[e_j,e_j+1,……,e_n]` （第 34-37 行）。 最后尝试再次测试应用性质（第 24-26 行）。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:197
msgid "GuidedPolicy类中的成员方法"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:204
msgid "获取主路径的方法"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:206
msgid "**select_main_path**"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:208
msgid "select_main_path从用户定义的所有主路径中随机选择一条作为本轮测试的引导路径。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:223
msgid "事件生成管理的成员方法"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath
#: ../source/part-designDocument/InputGenerator/random.rst:107 Guided
#: Policy.rst:225
msgid "**generate_event**"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:227
msgid ""
"根据当前应用状态判断应当生成事件的方法。如果在应用外则返回应用；如果在初始阶段则运行初始化函数；如果在执行主路径则返回主路径事件； "
"如果在探索应用则返回继续探索所需事件。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath
#: ../source/part-designDocument/InputGenerator/llm.rst:295
#: ../source/part-designDocument/InputGenerator/llm.rst:342
#: ../source/part-designDocument/InputGenerator/random.rst:112
#: ../source/part-designDocument/InputGenerator/random.rst:152
#: ../source/part-designDocument/kea/kea.rst:67
#: ../source/part-designDocument/kea/kea.rst:206
#: ../source/part-designDocument/kea/kea.rst:232
#: ../source/part-designDocument/kea/kea.rst:258
#: ../source/part-designDocument/kea/keaTestElements.rst:62
#: ../source/part-designDocument/kea/keaTestElements.rst:79
#: ../source/part-designDocument/kea/keaTestElements.rst:95 Guided
#: Policy.rst:230 Policy.rst:263 Policy.rst:287 Policy.rst:325 Policy.rst:347
#: Policy.rst:372
msgid "无"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:233
msgid "一个生成的事件。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:257
msgid "在主路径上获取事件的成员方法"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:259
msgid "**get_next_event_from_main_path**"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:261
msgid "获取主路径上应该执行的下一个事件。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:265
msgid "主路径上的下一个事件。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:281
msgid "应用状态探索过程的成员方法"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:283
msgid "**mutate_the_main_path**"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:285
msgid "根据当前事件执行次数判断是继续生成随机事件还是回到主路径上。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:290
msgid "探索过后生成的事件。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath
#: ../source/part-designDocument/InputGenerator/random.rst:147 Guided
#: Policy.rst:321
msgid "**generate_random_event_based_on_current_state**"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:323
msgid "生成随机事件探索应用。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:327
msgid "随机生成的事件。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:343
msgid "**stop_mutation**"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:345
msgid "停止探索过程，并重置参数。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:349
msgid "重启或者重装应用事件。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:366
msgid "从探索过程返回主路径的成员方法"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:368
msgid "**get_event_from_main_path**"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:370
msgid "根据当前是否已经回到主路径上，如果已经回到则执行完后续主路径事件，如果没回到主路径上则根据主路径事件序列倒叙尝试返回主路径。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:375
msgid "主路径事件字符串。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:401
msgid "**get_ui_element_dict**"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:403
msgid "获取主路径上单个事件所操作的组件的相关信息。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:406
msgid "ui_element_str: 组件信息字符串"
msgstr ""

#: ../source/part-designDocument/InputGenerator/MainPath Guided Policy.rst:408
msgid "字典形式的该组件相关信息。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:4
msgid "LLMPolicy"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:6
msgid ""
"LLMPolicy类是使用LLM（Large Language Model）在检测到UI陷阱时生成输入事件的核心类。 "
"主要负责在应用状态空间中遇到难以探索的UI状态时，利用LLM生成输入事件以增强功能场景覆盖。 "
"该类提供了完整的LLM辅助事件生成策略的事件生成过程。 LLMPolicy所包含的主要方法有："
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:11
msgid "根据当前状态生成一个LLM辅助的随机事件。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:12
#: ../source/part-designDocument/InputGenerator/random.rst:12
msgid "根据配置重启或重新安装应用。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:13
#: ../source/part-designDocument/InputGenerator/random.rst:13
msgid "在满足预条件的情况下，根据随机性决定是否检查性质。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:16
msgid "LLM辅助事件生成策略的介绍"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:18
msgid ""
"LLM辅助事件生成策略是一种结合了大型语言模型的策略，它可以在应用的GUI测试中遇到难以通过传统随机策略探索的状态时，利用LLM生成更有效的输入事件。"
" 这种策略特别适用于那些需要深入探索应用状态空间或需要优化测试覆盖率的场景。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:24
msgid "LLM辅助事件生成策略的流程图"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:28
msgid "步骤1：开始执行 LLMPolicy 类的事件生成过程。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:30
msgid "步骤2：初始化 LLMPolicy 实例，设置日志记录器、动作历史记录等。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:32
msgid "步骤3：启动事件生成循环，直到输入管理器的事件计数结束或条件不再满足。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:34
msgid "步骤4：检查事件计数器是否小于输入管理器设定的事件计数。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:36
msgid "步骤5：如果事件计数器小于输入管理器设定的事件计数，获取当前应用状态。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:38
msgid "步骤6：判断当前状态是否为空。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:40
msgid "步骤7：如果当前状态为空，等待5秒并返回一个名称为\"BACK\"的键事件。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:42
msgid "步骤8：如果当前状态不为空，检查是否检测到UI陷阱。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:44
msgid "步骤9：如果检测到UI陷阱，检查模拟计数器是否超过了最大查询LLM次数。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:46
msgid "步骤10：如果模拟计数器超过了最大查询LLM次数，记录日志并返回一个名称为\"BACK\"的键事件。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:48
msgid "步骤11：如果模拟计数器未超过最大查询LLM次数，生成一个LLM事件。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:50
msgid "步骤12：如果未检测到UI陷阱，生成一个随机事件。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:52
msgid "步骤13：基于当前用户触发的事件（UTG）生成LLM事件。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:54
msgid "步骤14：返回生成的事件，该事件将被用于与应用的交互。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:56
msgid "步骤15：保存截图并将生成的事件添加到输入管理器。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:58
msgid "步骤16：更新当前状态和最后事件。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:60
msgid "步骤17：检查是否允许生成UTG。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:62
msgid "步骤18：如果允许生成UTG，更新UTG。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:64
msgid "步骤19：生成报告，包括所有状态和触发的bug信息。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:66
msgid "步骤20：事件计数器加1，回到步骤4继续循环。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:68
msgid "步骤21：如果事件计数器达到输入管理器设定的事件计数，结束事件生成循环。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:70
msgid "步骤22：清理资源，结束 LLMPolicy 类的事件生成过程。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:73
msgid "LLM辅助事件生成策略的伪代码"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:75
msgid ":math:`\\textbf{Algorithm:} LLM-Assisted Event Generation`"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:77
#: ../source/part-designDocument/InputGenerator/random.rst:55
msgid ":math:`\\textbf{Input:} None`"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:204
msgid "LLMPolicy类中的数据结构"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:206
#: ../source/part-designDocument/InputGenerator/random.rst:85
msgid "**event_count**"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:208
msgid "``event_count`` 整型，记录了已经生成的事件数量。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:210
#: ../source/part-designDocument/InputGenerator/random.rst:89
msgid "**number_of_events_that_restart_app**"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:212
msgid "``number_of_events_that_restart_app`` 整型，记录了在重启应用前需要生成的事件数量。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:214
msgid "**clear_and_restart_app_data_after_100_events**"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:216
msgid "``clear_and_restart_app_data_after_100_events`` 布尔型，指示是否在100次事件后清除并重启应用数据。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:218
#: ../source/part-designDocument/InputGenerator/random.rst:97
msgid "**restart_app_after_check_property**"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:220
msgid "``restart_app_after_check_property`` 布尔型，指示在检查性质后是否重启应用。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:222
msgid "**_action_history**"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:224
msgid "``_action_history`` 列表，记录了动作历史。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:226
msgid "**_all_action_history**"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:228
msgid "``_all_action_history`` 集合，记录了所有动作历史记录。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:230
msgid "**_activity_history**"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:232
msgid "``_activity_history`` 集合，记录了活动历史记录。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:234
msgid "**from_state**"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:236
msgid "``from_state`` 对象，记录了起始状态。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:238
msgid "**task**"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:240
msgid "``task`` 字符串，记录了LLM的任务描述。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:244
msgid "LLMPolicy类中的成员方法"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:247
msgid "启动事件生成的方法"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:251
msgid "``start`` 方法用于启动事件生成过程。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:254
msgid "input_manager: InputManager的实例。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:257
msgid "初始化事件计数器和输入管理器。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:258
msgid "循环生成事件直到达到输入管理器设定的事件计数或条件不再满足。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:259
msgid "根据当前状态和LLM的指导生成事件。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:260
msgid "将生成的事件添加到输入管理器中并更新设备状态。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:261
msgid "处理异常情况并在每次事件后增加事件计数器。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:288
msgid "生成LLM事件的方法"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:290
msgid "**generate_llm_event**"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:292
msgid "``generate_llm_event`` 方法用于生成一个LLM辅助的事件。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:298
#: ../source/part-designDocument/InputGenerator/llm.rst:345
#: ../source/part-designDocument/InputGenerator/random.rst:115
#: ../source/part-designDocument/InputGenerator/random.rst:155
msgid "生成的事件对象。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:301
#: ../source/part-designDocument/InputGenerator/random.rst:118
msgid "检查是否需要运行初始化器并获取当前应用状态。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:302
#: ../source/part-designDocument/InputGenerator/random.rst:119
msgid "根据事件计数和设置决定是否重启应用或清除并重新安装应用。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:303
#: ../source/part-designDocument/InputGenerator/random.rst:120
msgid "检查是否有满足前提条件的规则，并根据随机性决定是否检查性质。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:304
msgid "生成基于LLM的事件。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:335
msgid "生成基于UTG的LLM事件的方法"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:337
msgid "**generate_llm_event_based_on_utg**"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:339
msgid "``generate_llm_event_based_on_utg`` 方法用于基于当前UTG生成一个LLM辅助的事件。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:348
#: ../source/part-designDocument/InputGenerator/random.rst:158
msgid "获取当前应用状态。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:349
msgid "如果应用不在活动堆栈中，尝试启动应用。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:350
msgid "如果应用在活动堆栈中但不在前台，尝试返回前台。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:351
msgid "如果应用在前台，根据LLM的指导选择下一步操作。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:377
msgid "查询LLM的方法"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:379
msgid "**_query_llm**"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:381
msgid "``_query_llm`` 方法用于向LLM查询以生成事件。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:384
msgid "prompt: 提供给LLM的提示文本。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:385
msgid "model_name: 使用的LLM模型名称，默认为\"gpt-3.5-turbo\"。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:388
msgid "LLM的响应文本。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:391
msgid "设置LLM客户端。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:392
msgid "发送提示文本到LLM。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:393
msgid "接收并返回LLM的响应。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:406
msgid "获取动作与LLM交互的方法"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:408
msgid "**_get_action_with_LLM**"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:410
msgid "``_get_action_with_LLM`` 方法用于获取基于LLM的下一个动作。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:413
msgid "current_state: 当前应用状态。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:414
msgid "action_history: 动作历史记录。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:415
msgid "activity_history: 活动历史记录。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:418
msgid "选中的动作和候选动作列表。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:421
msgid "构建包含任务描述、当前状态和历史记录的提示文本。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:422
msgid "向LLM查询并接收响应。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:423
msgid "解析响应以获取动作索引。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/llm.rst:424
msgid "根据索引选择动作并更新历史记录。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/random.rst:4
msgid "RandomPolicy"
msgstr ""

#: ../source/part-designDocument/InputGenerator/random.rst:6
msgid ""
"RandomPolicy类是随机事件生成策略的核心类。 主要负责基于当前应用状态生成随机事件。 该类提供了完整的随机事件生成策略的事件生成过程。 "
"RandomPolicy所包含的主要方法有："
msgstr ""

#: ../source/part-designDocument/InputGenerator/random.rst:11
msgid "根据当前状态生成一个随机事件。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/random.rst:16
msgid "随机事件生成策略的介绍"
msgstr ""

#: ../source/part-designDocument/InputGenerator/random.rst:18
msgid ""
"随机事件生成策略是一种简单有效的策略，它可以在没有明确指导路径的情况下探索应用的状态空间。 "
"具体来说，该策略会根据当前应用的状态随机生成事件，以期达到未探索的状态或触发应用中的某些性质。 "
"这种策略特别适用于那些没有明确测试路径或需要广泛覆盖应用状态的场景。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/random.rst:25
msgid "随机探索策略的流程图"
msgstr ""

#: ../source/part-designDocument/InputGenerator/random.rst:29
msgid "步骤1：检查是否满足生成事件的条件，即事件计数是否为首次生成事件或者上一个事件是否为应用重新安装事件。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/random.rst:31
msgid "步骤2：如果满足条件，则运行初始化器并获取设备当前状态。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/random.rst:33
msgid "步骤3：判断当前状态是否为空，如果是，则等待5秒并返回一个名称为\"BACK\"的键事件。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/random.rst:35
msgid "步骤4：检查事件计数是否是重启应用事件数量的倍数，如果是，则根据配置决定是清除并重新安装应用还是仅仅重启应用。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/random.rst:37
msgid "步骤5：获取所有满足预条件的规则，如果存在这样的规则，则记录当前时间，并根据随机性决定是否检查性质。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/random.rst:39
msgid "步骤6：如果决定检查性质，则执行性质检查。如果检查后需要重启应用，则记录日志并返回应用杀进程事件；否则，不重启应用。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/random.rst:41
msgid "步骤7：如果因为随机性决定不检查性质，则记录日志并继续。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/random.rst:43
msgid "步骤8：基于当前应用状态生成一个随机事件。这包括将应用移至前台（如果需要），获取当前状态可能的输入事件，并添加返回键和旋转设备事件。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/random.rst:45
msgid "步骤9：从可能的事件列表中随机选择一个事件。如果选择的是旋转设备事件，则根据上次旋转事件的方向选择相反方向的旋转事件。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/random.rst:47
msgid "步骤10：返回生成的随机事件，该事件将被用于与应用的交互。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/random.rst:50
msgid "随机事件生成策略的伪代码"
msgstr ""

#: ../source/part-designDocument/InputGenerator/random.rst:53
msgid ":math:`\\textbf{Algorithm:} Random Event Generation`"
msgstr ""

#: ../source/part-designDocument/InputGenerator/random.rst:57
msgid ":math:`\\textbf{Output:} Generated Event`"
msgstr ""

#: ../source/part-designDocument/InputGenerator/random.rst:83
msgid "RandomPolicy类中的数据结构"
msgstr ""

#: ../source/part-designDocument/InputGenerator/random.rst:87
msgid "event_count整型，记录了已经生成的事件数量。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/random.rst:91
msgid "number_of_events_that_restart_app整型，记录了在重启应用前需要生成的事件数量。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/random.rst:93
msgid "**clear_and_reinstall_app**"
msgstr ""

#: ../source/part-designDocument/InputGenerator/random.rst:95
msgid "clear_and_reinstall_app布尔型，指示是否在重启应用前清除并重新安装应用。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/random.rst:99
msgid "restart_app_after_check_property布尔型，指示在检查性质后是否重启应用。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/random.rst:102
msgid "RandomPolicy类中的成员方法"
msgstr ""

#: ../source/part-designDocument/InputGenerator/random.rst:105
msgid "生成随机事件的方法"
msgstr ""

#: ../source/part-designDocument/InputGenerator/random.rst:109
msgid "``generate_event`` 方法用于生成一个随机事件。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/random.rst:121
msgid "生成基于当前状态的随机事件。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/random.rst:145
msgid "生成随机事件的成员方法"
msgstr ""

#: ../source/part-designDocument/InputGenerator/random.rst:149
msgid "``generate_random_event_based_on_current_state`` 方法用于基于当前状态生成一个随机事件。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/random.rst:159
msgid "如果需要，将应用移至前台。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/random.rst:160
msgid "获取当前状态可能的输入事件。"
msgstr ""

#: ../source/part-designDocument/InputGenerator/random.rst:161
msgid "根据随机选择生成一个事件。"
msgstr ""

#: ../source/part-designDocument/fuzzer/droidbot.rst:2
msgid "DroidBot"
msgstr ""

#: ../source/part-designDocument/fuzzer/droidbot.rst:4
msgid ""
"DroidBot是kea在应用探索阶段与安卓设备交互的类。主要提供生成事件，截图等方法。DroidBot同时提供一个UTG(UI "
"Transition Graph, 事件迁移图)。 可以基于事件迁移图，以基于模型的测试(MBT, Model Based "
"Testing)编写更高级的应用探索策略。"
msgstr ""

#: ../source/part-designDocument/fuzzer/droidbot.rst:10
msgid "Droidbot为本项目的参考项目。"
msgstr ""

#: ../source/part-designDocument/fuzzer/droidbot.rst:12
msgid "https://github.com/honeynet/droidbot"
msgstr ""

#: ../source/part-designDocument/fuzzer/droidbot.rst:15
msgid "Droidbot项目架构"
msgstr ""

#: ../source/part-designDocument/fuzzer/droidbot.rst:17
msgid "Droidbot项目架构组成部分有："
msgstr ""

#: ../source/part-designDocument/fuzzer/droidbot.rst:19
msgid "App： 用于解析安卓应用安装包(.hap)或安卓包(package)。提供EntryActivity等信息。"
msgstr ""

#: ../source/part-designDocument/fuzzer/droidbot.rst:20
msgid "Device： 一个安卓设备的抽象，提供设备层面的一些操作接口，如发送文件，输入内容，旋转设备，获取前台应用等。"
msgstr ""

#: ../source/part-designDocument/fuzzer/droidbot.rst:21
msgid "ADB： 安卓设备adb指令的抽象，提供通过adb与设备交互的接口，如shell，pull_file等。Device依赖于本类。"
msgstr ""

#: ../source/part-designDocument/fuzzer/droidbot.rst:22
msgid "uiautomator2： 安卓设备测试工具uiautomator2，为Droidbot拓展提供输入事件等功能。"
msgstr ""

#: ../source/part-designDocument/fuzzer/droidbot.rst:23
#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:23
msgid "InputManager： 输入控制器，提供策略选择等功能。"
msgstr ""

#: ../source/part-designDocument/fuzzer/droidbot.rst:24
#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:24
msgid "InputPolicy： 输入策略，提供多种输入策略，如随机策略，大模型指引策略等，用于规定探索应用的规则。"
msgstr ""

#: ../source/part-designDocument/fuzzer/droidbot.rst:25
#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:25
msgid "EventLog： 事件日志的抽象，执行事件输入前，事件输入后的记录操作，以及发送事件的操作。"
msgstr ""

#: ../source/part-designDocument/fuzzer/droidbot.rst:26
#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:26
msgid "InputEvent： 输入事件的类，包含点击、长按、输入等事件。"
msgstr ""

#: ../source/part-designDocument/fuzzer/droidbot.rst:27
#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:27
msgid "UTG： 事件迁移图(UI Transition Graph)的类，用于应用建模，可以被输入策略使用进行更复杂的决策。"
msgstr ""

#: ../source/part-designDocument/fuzzer/droidbot.rst:28
#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:28
msgid "DeviceState： 用于应用界面抽象的类，对应用界面进行不同层次的抽象，提供给UTG类进行建模。"
msgstr ""

#: ../source/part-designDocument/fuzzer/droidbot.rst:30
msgid ""
"因为InputManager, "
"InputPolicy与Kea的输入策略重点相关，故另开章节进行介绍。uiautomator2为参考的框架，未做开发修改。 "
"其他功能基本沿用原来的Droidbot。故在本节不介绍，重要的类会在团队参考Droidbot开发的鸿蒙版Droidbot：HMDroidbot中介绍。"
msgstr ""

#: ../source/part-designDocument/fuzzer/droidbot.rst:36
msgid "Droidbot 架构图"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:2
msgid "HMDroidbot"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:4
msgid ""
"HMDroidbot是kea在应用探索阶段与安卓设备交互的类。主要提供生成事件，截图等方法。HMDroidbot同时提供一个UTG(UI "
"Transition Graph, 事件迁移图)。 可以基于事件迁移图，以基于模型的测试(MBT, Model Based "
"Testing)编写更高级的应用探索策略。"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:9
msgid "HMDroidbot为本项目工作的一部份，为队伍中梁锡贤同学开发，开发过程参考项目为droidbot，应计入本项目工作。"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:11
msgid "https://github.com/ecnusse/HMDroidbot"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:14
msgid "HMDroidbot项目架构"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:16
msgid "HMDroidbot项目架构组成部分有："
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:18
msgid "AppHM： 用于解析鸿蒙应用安装包(.hap)或鸿蒙包(package)。提供EntryAbility等信息。"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:19
msgid "DeviceHM： 一个鸿蒙设备的抽象，提供设备层面的一些操作接口，如发送文件，输入内容，旋转设备，获取前台应用等。"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:20
msgid "HDC： 鸿蒙设备hdc指令的抽象，提供通过hdc与设备交互的接口，如shell，pull_file等。DeviceHM依赖于本类。"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:21
msgid "Dumper： 鸿蒙设备获取界面布局的抽象类，HDC依赖于该类"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:22
msgid "hmdriver2： 鸿蒙设备测试工具hmdriver2，为DeviceHM拓展提供输入事件等功能。"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:33
msgid "HMDroidbot 项目架构图"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:35
msgid ""
"因为InputManager, "
"InputPolicy与Kea的输入策略重点相关，故另开章节进行介绍。hmdriver2为参考的框架，未做开发修改。 "
"以下介绍除上述三个功能外的其他组成部分。其中EventLog、InputEvent、UTG基本复用droidbot。"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:39
msgid "AppHM"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:41
msgid "AppHM是一个鸿蒙应用的抽象，用于分析一个鸿蒙应用。对外提供对鸿蒙应用的分析方法，获取应用入口(EntryAbility)等信息。"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:43
msgid "AppHM会根据传入的应用是一个安装包(.hap)或一个包名(如com.example.app)，选择对应的方法进行初始化。"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:54
msgid "以下是AppHM的方法和文档："
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "方法"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "输入"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "输出"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "简介"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "hap_init"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "app_path:str"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "给定一个安装包路径，通过安装包初始化app"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "load_hap_info"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "pack_info:Dict"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "对安装包进行解压缩，读取其中信息"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "package_init"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "package_name:str"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "通过包名初始化app"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "dumpsys_package_info"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "package_info:Dict"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "从dumpsys指令获取包信息"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "get_package_name"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "获取app包名"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "get_start_intent"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "start_intent:Intent"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "获取启动应用的Intent"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "get_stop_intent"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "获取停止应用的Intent"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "get_hashes"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "hashes:List[str]"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "获取应用安装包的哈希"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:69
msgid "DeviceHM"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:71
msgid "DeviceHM是一个鸿蒙设备的抽象，提供设备层面的一些操作接口，如发送文件，输入内容，旋转设备，获取前台应用等。"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:73
msgid "以下是DeviceHM的方法和文档。"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:77
msgid "设备适配器(adapters)是终端与应用进行交互的适配器，DeviceHM可以通过多种不同的工具与终端交互。 如HDC、hmdriver2等。"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "check_connectivity"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "检查设备和设备适配器是否可用"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "set_up"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "初始化设备和设备适配器"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "connect"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "连接设备和设备适配器"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "disconnect"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "断开设备和设备适配器"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "is_foreground"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "app:AppHM"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "Boolean"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "检查某个应用是否在设备中处于前台状态"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "model_number"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "model_number:str"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "获取设备的设备号"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "device_name"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "device_name:str"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "获取设备名称"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "get_release_version"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "sdk_api:str"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "获取设备的SDK API版本"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "get_display_info"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "display_info:Dict"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "获取设备的分辨率"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "get_width"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "width:str"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "获取设备横向分辨率"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "get_height"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "height:str"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "获取设备纵向分辨率"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "unlock"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "解锁设备"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "send_intent"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "intent:Intent"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "向设备中发送一个Intent"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "send_evnet"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "event:InputEvent"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "向设备发送一个事件"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "start_app"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "启动一个应用"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "get_top_activity_name"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "top_ability_name"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "获取设备的栈顶Ability名称"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "get_current_activity_stack"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "current_ability_stack:List[str]"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "获取设备的Ability栈"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "install_app"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "安装一个应用"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "uninstall_app"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "卸载一个应用"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "push_file"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "local_file:Path, remote_dir:Path"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "推送一个文件到设备上"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "pull_file"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "remote_file:Path, local_file:Path"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "从设备拉取一个文件"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "take_screenshot"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "对设备进行截图"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "get_current_state"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "action_count:int"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "current_state:DeviceState"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "获取当前设备的状态抽象"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "view_touch"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "x:int, y:int"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "根据坐标执行点击操作"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "view_long_touch"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "x:int, y:int, duration:float"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "根据坐标执行长按操作"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "view_drag"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "start_xy:List[int], end_xy:List[int], duration:float"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "根据坐标执行拖动操作"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "view_append_text"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "text:str"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "添加一个文本"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "view_set_text"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "设置一个文本"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "key_press"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "key_code"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "根据事件代码输入一个事件"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "get_views"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "获取当前设备上的控件"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "get_random_port"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "port:int"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "随机获取一个可用端口"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:116
msgid "HDC"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:118
msgid "鸿蒙设备hdc指令的抽象，提供通过hdc与设备交互的接口，如shell，pull_file等。DeviceHM依赖于本类。"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:120
msgid "鸿蒙设备通过Dumper类获取应用的界面。Dumper类是一个抽象类，共有两种实现：UitestDumper和HiDumper。"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:125
msgid "Dumper 类与 HDC 类的关系示意"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:128
msgid "以下是HDC的方法和文档。"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "初始化HDC"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "run_cmd"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "执行一个 hdc 命令行命令"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "shell"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "执行一个 hdc shell 命令行命令"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "连接HDC"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "断开HDC"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "检查HDC是否可用"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "get_property"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "property_name"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "preoperty"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "通过hdc获取设备的属性"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "get_model_number"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "获取设备的模型号"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "get_sdk_version"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "sdk_version:str"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "获取SDK版本"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "get_device_name"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "get_installed_apps"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "installed_apps:List[str]"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "获取已安装的应用"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "get_display_density"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "dpi:str"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "获取设备显示的dpi"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "通过hdc解锁设备"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "touch"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "通过hdc根据坐标执行点击操作"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "long_touch"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "通过hdc根据坐标执行长按操作"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "drag"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "通过hdc根据坐标执行拖动操作"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "type"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "通过hdc添加一个文本"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "press"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "通过hdc根据事件代码输入一个事件"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "通过hdc推送一个文件到设备上"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "通过hdc从设备拉取一个文件"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "output_dir"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "获取当前页面的控件"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:156
msgid "Dumper主要从设备中获取当前页面的布局，并转换为安卓风格使droidbot能使用。"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:158
msgid "以下是UiTestDumper的实现："
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "dump_view"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "view_path"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "通过uitest获取layout json，并返回"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "preprocess_views"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "views_path"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "处理views，转换为可双向查询的树结构"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "get_adb_view"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "raw_view:Dict"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "处理views，转换为安卓风格方便droidbot使用"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "get_view"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "views:Dict"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "获取views"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:168
msgid "以下是HiDumper的实现："
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "get_focus_window"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "focus_window"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "获取当前前台窗口"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "dump_target_window_to_file"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "focus_window:int, fp:IO"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "拉取目标窗口的布局入文件中"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "dump_layout"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "fp:IO"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "根据hidumper的输出处理布局为树结构"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "adapt_hierachy"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "处理布局为安卓风格"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "“get_views\""
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:181
msgid "InputEvent"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:183
msgid "InputEvent是一个抽象类，其他所有的事件实现在此抽象接口上。"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:188
msgid "InputEvent接口和其实现"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:190
msgid "以下是InputEvent抽象类的方法："
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "send"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "device:HMDevice"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "向设备发送事件"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "to_dict"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "event_dict:Dict"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "以字典形式保存当前事件"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "from_dict"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "从字典解析获取一个InputEvent实例"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "get_event_str"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "state:DeviceState"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "event_str:str"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "根据当前状态获取事件表示"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "views:List[str]"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "获取当前事件对应的views"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:202
msgid "UTG"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:204
msgid "事件迁移图(UI Transition Graph)的类，用于应用建模，可以被输入策略使用进行更复杂的决策。"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:206
msgid "以下是UTG的方法和文档。"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "first_state_str"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "state_str:str"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "第一个事件的状态哈希"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "last_state_str"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "最后一个事件的状态哈希"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "effective_event_count"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "count:int"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "造成迁移的事件数量"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "nums_transitions"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "发现的状态迁移数量"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "clear_graph"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "清除UTG"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "add_transition"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "event:InputEvent, old_state:str, new_state:str"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "添加一个迁移"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "remove_transition"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "删除一个迁移"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "add_node"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "state:DeviceState, event:InputEvent"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "添加一个状态节点"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "is_event_explored"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "event:InputEvent, state:str"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "判断一个事件是否已经执行过"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "is_state_reached"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "state:str"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "判断一个状态是否已经到达过"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "get_reachable_states"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "current_state:str"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "reachable_states:List[str]"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "获取当前状态可迁移至的状态"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "reachable_from_one_state_to_another"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "from_state:str, to_state:str"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "判断两个状态是否可迁移"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "get_navigation_steps"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "List[Tuple[str, InputEvent]]"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "获取从一个节点导航至另一个节点的步骤"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "find_activity_according_to_state_str"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "根据状态哈希获取状态对应的Ability"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:227
msgid "DeviceState"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:229
msgid "DeviceState是用于应用界面抽象的类，对应用界面进行不同层次的抽象，提供给UTG类进行建模。"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:231
msgid "以下是DeviceState的方法和文档。"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "get_possible_input"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "possible_input:List[InputEvent]"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "获取当前状态上可执行的事件"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "get_text_representation"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "state_desc:str, activity:str, indexed_views:List[str]"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "获取当前状态的描述信息"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "get_view_by_attribute"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "attribute_dict:Dict, random_select:Bool"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "根据属性获取可用的控件"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "is_view_exist"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "view_dict:Dict"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "判断某个控件是否存在"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "get_view_desc"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "view:Dict"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "view_desc:str"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "获取控件的描述"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "assemble_view_tree"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "root_view:Dict, views:List[Dict]"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "将view组织为树结构"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "get_view_str"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "view_str:str"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "获取一个view的描述"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "get_pagePath"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "pagePath:str"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "获取当前界面对应的pagePath"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "get_state_str_raw"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "state_str_raw:str"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "获取当前页面的状态描述"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "get_state_str"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "获取当前页面的状态哈希"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "get_content_free_state_str"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "content_free_str:str"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "获取当前页面的结构哈希"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "save_view_img"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "view_dict:Dict, output_dir:str"
msgstr ""

#: ../source/part-designDocument/fuzzer/hmdroidbot.rst:1
msgid "保存控件截图"
msgstr ""

#: ../source/part-designDocument/intro.rst:4
msgid "架构图"
msgstr "Project Structure"

#: ../source/part-designDocument/intro.rst:9
msgid "Kea 架构图"
msgstr "Kea Project Structure"

#: ../source/part-designDocument/intro.rst:13
msgid "目录结构"
msgstr ""

#: ../source/part-designDocument/intro.rst:59
msgid "各功能部分设计文档"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:2
msgid "Kea"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:4
msgid "本部分旨在解释 Kea 的中的核心控制器类 Kea 的设计与实现。"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:9
msgid "Kea类是工具中的核心类，为工具中与基于性质测试相关功能的控制器。在Kea类中，存储的内容和对外暴露的方法主要有："
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:11
msgid "加载所有KeaTest并读取至KeaTest至KeaTestElements的相关方法。"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:12
msgid "存储用户定义的所有KeaTestElements。以及访问这些性质相关函数(initializer, rule, mainPath)的方法。"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:13
msgid "存储当前运行的PDL驱动（含安卓与鸿蒙系统）。以及设置当前要运行的PDL驱动的方法。"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:14
msgid "性质的前置条件检查器方法，返回当前应用界面中通过了前置条件的性质。"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:15
msgid "执行一条性质的交互场景的方法。"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:16
msgid "执行主路径步骤的方法。"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:21
msgid "Kea 类的组成"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:24
msgid "Kea类中的数据结构实现"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:26
msgid "**KeaTest_DB**"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:28
msgid ""
"KeaTest_DB是Kea运行时的数据库，用于存储所有的用户自定义性质。每个数据项以 <keaTest, keaTestElements> "
"的键值对方式存储。"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:31
msgid "**pdl_driver**"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:33
msgid ""
"pdl_driver 存储的是当前的 PDL (Property Description Languague, 性质描述语言) 的驱动。 "
"此处存储的是鸿蒙或安卓设备的驱动，主要用于执行主路径中的某一步。"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:37
msgid "Kea类中的成员方法实现"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:40
msgid "读取性质的相关方法"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:42
msgid ""
"读取性质的相关方法主要对外提供读取用户自定义相关性质的方法。这些性质被读取后会按keaTestElements数据结构的方式组织， "
"并存储进入KeaTest_DB。"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:45
msgid "**load_app_properties**"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:47
msgid "load_app_properties 从用户指定的性质文件中读取性质并存储入Kea，其核心流程如下。"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:58
msgid "具体步骤的简化的python风格代码如下："
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:60
msgid "*注：为了描述清晰，简化的代码仅对核心流程进行抽象并展示，实际代码与简化的参考代码不完全一致。 下文将展示的其他简化代码遵循的规则相同。*"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:64
msgid "``property_files:List[str]`` : 用户自定义性质的文件路径列表"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:93
msgid "**load_KeaTest**"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:95
msgid ""
"load_KeaTest 从 KeaTest 中取出用户自定义的性质（含初始化函数对象、交互场景、主路径函数对象）， 转换为 "
"KeaTestElements 数据结构并存储入 KeaTest_DB 。"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:98
msgid "load_KeaTest 的流程如下："
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:105
msgid "其实现通过简化的python代码展示如下："
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:108
#: ../source/part-designDocument/kea/keaTestElements.rst:59
#: ../source/part-designDocument/kea/keaTestElements.rst:76
#: ../source/part-designDocument/kea/keaTestElements.rst:92
msgid "``keaTest:KeaTest`` : 用户自定义性质的keaTest对象"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:111
msgid "``keaTestElements:KeaTestElements`` : 读取了keaTest对象的keaTestElements对象"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:135
msgid "性质执行相关方法"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:137
msgid "性质执行的相关方法主要对外提供与性质执行相关功能的接口，主要交由输入策略调用。如获取当前页面通过前置条件的性质， 执行一条性质的交互场景等。"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:140
msgid "**execute_rules**"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:142
msgid "对一组rules(性质)，随机选择一条性质并调用execute_rule方法尝试执行之。"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:144
msgid "其python风格的简化代码定义实现如下。"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:147
#: ../source/part-designDocument/kea/kea.rst:177
msgid "``rules:List[Rule]`` : 性质交互场景列表"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:150
msgid "执行结果"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:162
msgid "**execute_rule**"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:164
msgid "对于一条rule(性质)，执行之并返回执行结果。其返回的结果CHECK_RESULT是一个结构体常量，如下为它的五种返回情况及其含义："
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:174
msgid "其python风格的简化代码实现如下。"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:180
msgid "``CHECK_RESULT``: 执行结果"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:199
msgid "**get_rules_whose_preconditions_are_satisfied**"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:201
msgid "对于一组性质，检查他们的前置条件，并获取通过前置条件的性质。"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:203
#: ../source/part-designDocument/kea/kea.rst:229
msgid "其python风格的简化代码如下："
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:209
msgid "``rules_passed_precondition:Dict[Rule, KeaTest]``: 通过了前置条件的性质列表"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:222
msgid "**get_rules_without_precondition**"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:224
msgid "对于一组性质，若他们的前置条件，并获取无前置条件的性质。"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:227
msgid "无前置条件的性质被视为无条件执行，等价于前置条件恒成立。"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:235
msgid "``rules_passed_precondition:Dict[Rule, KeaTest]``: 无前置条件的性质列表"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:247
msgid "**execute_event_from_main_path**"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:249
msgid ""
"对于给定的一个主路径步骤的源代码，尝试执行之。因为主路径中是用户利用PDL驱动编写的步骤， "
"因此需要获取驱动对象，并让其执行相应操作。驱动储存在前述数据结构的pdl_driver中。"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:252
msgid "其python代码如下。"
msgstr ""

#: ../source/part-designDocument/kea/kea.rst:255
msgid "``executable_script:str`` : 可执行的主路径步骤源代码"
msgstr ""

#: ../source/part-designDocument/kea/keaTestElements.rst:2
msgid "KeaTestElements"
msgstr ""

#: ../source/part-designDocument/kea/keaTestElements.rst:4
msgid "本部分旨在解释 Kea 运行时数据管理类 KeaTestElements 的设计与实现。"
msgstr ""

#: ../source/part-designDocument/kea/keaTestElements.rst:9
msgid ""
"KeaTestElements是Kea运行时存储用户自定义性质的数据结构，与用户继承并自定义的keaTest一一对应。 "
"在kea启动时，keaTestElements会读取每个用户自定义的keaTest，并重新组织为方便kea进行读取的数据结构。 "
"具体的转换过程可参考装饰器一章：:ref:`decorators-keatestelements`。"
msgstr ""

#: ../source/part-designDocument/kea/keaTestElements.rst:14
msgid "KeaTestElements的数据结构图示如下："
msgstr ""

#: ../source/part-designDocument/kea/keaTestElements.rst:19
msgid "KeaTestElements 数据结构"
msgstr ""

#: ../source/part-designDocument/kea/keaTestElements.rst:21
msgid ""
"其中，keaTest_name是一个字符串，用于存储用户定义的keaTest的类名。Rules是一个列表，用于存储Rule对象。 "
"Initializers是一个列表，用于存储初始化函数对象Initializer。MainPaths是一个列表，用于存储主要路径对象MainPath。"
msgstr ""

#: ../source/part-designDocument/kea/keaTestElements.rst:24
msgid "其中，Rule、MainPath和Initializer对象的数据结构及定义可参见“装饰器”一章。"
msgstr ""

#: ../source/part-designDocument/kea/keaTestElements.rst:26
msgid "KeaTestElements的成员方法定义伪代码如下："
msgstr ""

#: ../source/part-designDocument/kea/keaTestElements.rst:37
msgid ""
"load_rules接收一个用户自定义的keaTest对象，读取其中的rule并将一个keaTest中的所有rule存储入rules列表。 "
"load_initializers接收一个用户自定义的keaTest对象，读取其中的初始化函数对象Initializer并将其存储入initializers列表。"
" load_mainPaths接收一个用户自定义的keaTest对象，读取其中的主路径对象mainPath并将其存储入mainPaths列表。"
msgstr ""

#: ../source/part-designDocument/kea/keaTestElements.rst:41
msgid "具体而言，在三个load方法的执行步骤相似，其执行步骤可描述如下："
msgstr ""

#: ../source/part-designDocument/kea/keaTestElements.rst:52
msgid "KeaTestElements 的成员方法读取KeaTest中的数据，转换为方便Kea使用的数据结构"
msgstr ""

#: ../source/part-designDocument/kea/keaTestElements.rst:54
msgid "三个成员方法的具体实现如下："
msgstr ""

#: ../source/part-designDocument/kea/keaTestElements.rst:56
msgid "**load_rules**"
msgstr ""

#: ../source/part-designDocument/kea/keaTestElements.rst:73
msgid "**load_initializers**"
msgstr ""

#: ../source/part-designDocument/kea/keaTestElements.rst:89
msgid "**load_mainPaths**"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:2
msgid "带状态的测试"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:4
msgid "本部分旨在解释 Kea 的带状态的测试是如何设计及实现的"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:8
#: ../source/part-designDocument/user-interface/cli/cli.rst:8
#: ../source/part-designDocument/user-interface/keaTest-suite/decorators.rst:7
msgid "功能说明与功能设计"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:10
msgid ""
"Bundle类是带状态测试的核心类。 主要负责记录多组不同类型数据的相关状态和操作的组合，用于测试系统在不同状态下的行为。 "
"该类提供了完整的成员方法用于状态的增删改查操作。 Bundle所包含的主要方法有："
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:15
msgid "根据当前类型数据的状态情况判断是否需要新增状态（单例模式）。"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:16
msgid "对某类型数据状态的增删改查。"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:17
#: ../source/part-designDocument/stateful_testing/Bundle.rst:141
msgid "随机生成指定长度的状态文本值。"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:18
#: ../source/part-designDocument/stateful_testing/Bundle.rst:160
msgid "随机获取某类型数据的一个状态。"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:23
msgid "Bundle 类的组成"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:26
msgid "Bundle类中的数据结构的实现"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:28
msgid "**_bundle_**"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:30
msgid ""
"_bundle_为Bundle的类变量，是带状态测试中各种类型数据的状态记录库，用于存储应用状态便于对状态的操作。 每个数据项以 <string,"
" Bundle> 的键值对方式存储。"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:33
msgid "**data_name**"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:35
msgid "data_name为string类型，存储了一个类型的数据的名称。"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:37
msgid "**data_value**"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:39
msgid "data_value是list类型，存储了该类型的数据的所有状态。"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:46
msgid "Bundle类中功能方法的实现"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:49
msgid "单例模式方法"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:51
msgid "**__new__**"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:53
msgid ""
"根据当前类型数据的名称判断是否已经实例化过该类型数据的Bundle对象，若没有实例化则实例化该类型Bundle对象并返回。 "
"否则，不实例化并返回之前实例化的对象。"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:57
msgid "``data_name``: 想要实例化的某个类型数据名称。"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:60
msgid "该类型数据的实例。"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:73
msgid "数据状态增删改查的成员方法"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:75
msgid "**add**"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:77
msgid "为当前类型数据增加状态。"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:80
msgid "``value``: 新增的状态值。"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:89
msgid "**delete**"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:91
msgid "为当前类型数据删除状态。"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:94
msgid "``value``: 要删除的状态值。"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:103
msgid "**update**"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:105
msgid "为当前类型数据更新状态。"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:108
msgid "``value``: 要修改的旧状态值。"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:109
msgid "``new_value``: 新的状态值。"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:124
msgid "**get_all_data**"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:126
msgid "获取该类型数据的所有状态。"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:129
msgid "状态列表"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:137
msgid "随机生成状态文本的成员方法"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:139
msgid "**get_random_text**"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:144
msgid "``value_max_len``: 需要状态文本值的最大长度。"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:147
msgid "合法的状态文本值"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:156
msgid "随机获取一个状态的成员方法"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:158
msgid "**get_random_data**"
msgstr ""

#: ../source/part-designDocument/stateful_testing/Bundle.rst:163
msgid "该类型数据的一个状态值"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:2
msgid "命令行交互功能"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:4
msgid "本部分旨在解释 Kea 的命令行界面（CLI）是如何设计及实现的，包括如何处理命令行参数、YAML 配置文件以及参数清洗。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:10
msgid "下述流程图的介绍了Kea工具CLI的启动和配置过程。涵盖了从命令行参数解析、配置文件加载、测试环境设置到自动化测试执行的整个自动化测试准备和启动过程。通过这种方式，用户可以灵活地配置测试环境，并自动化地执行测试用例。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:16
msgid "CLI实现的流程图"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:20
msgid "**解析命令行和配置文件参数**"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:22
msgid "使用 ``argparse`` 库创建一个参数解析器。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:23
msgid "定义接受的命令行参数，例如 ``-f`` 用于指定性质文件，``-d`` 用于指定设备序列号等。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:24
msgid "解析命令行输入的参数。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:26
msgid "**检查是否加载配置文件**"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:28
msgid "检查命令行参数中是否包含了 ``--load_config`` 标志，该标志指示是否从配置文件 ``config.yml`` 中加载参数。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:30
msgid "**从`config.yml`加载参数**"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:32
msgid ""
"如果指定了 ``--load_config`` ，则调用 ``load_ymal_args`` 函数从 ``config.yml`` "
"文件中读取参数。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:33
msgid "这些参数会覆盖命令行中指定的参数。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:35
msgid "**使用命令行参数**"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:37
msgid "如果没有指定 ``--load_config`` ，则直接使用命令行解析得到的参数。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:39
msgid "**设置参数并创建`Setting`实例**"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:41
msgid "根据解析得到的参数，创建一个 ``Setting`` 类的实例，该实例包含了所有需要的配置信息。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:43
msgid "**加载PDL驱动**"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:45
msgid "根据 ``Setting`` 实例中的 ``is_harmonyos`` 属性判断目标设备是Android还是HarmonyOS。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:46
msgid "根据平台加载相应的PDL（Property Description Language）驱动。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:48
msgid "**创建`Kea`实例**"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:50
msgid "创建 ``Kea`` 类的实例， ``Kea`` 可能是一个自动化测试框架的核心类。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:52
msgid "**加载应用性质**"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:54
msgid "使用 ``Kea.load_app_properties`` 方法加载需要测试的应用性质，这些性质定义了要测试的应用行为。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:56
msgid "**启动`Kea`**"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:58
msgid "调用 ``start_kea`` 函数，传入 ``Kea`` 实例和 ``Setting`` 实例，开始执行自动化测试流程。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:59
msgid "``start_kea`` 函数会初始化 ``DroidBot`` ，它是 ``Kea`` 的数据生成器，并启动测试。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:62
msgid "命令行参数解析"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:64
msgid "Kea 使用 `argparse` 库来解析命令行参数。以下是主要的命令行参数："
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:66
msgid "``-f`` 或 ``--property_files``: 指定要测试的应用性质文件。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:67
msgid "``-d`` 或 ``--device_serial``: 指定目标设备的序列号。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:68
msgid "``-a`` 或 ``--apk``: 指定待测应用安装包文件的路径，或待测应用的包名。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:69
msgid "``-o`` 或 ``--output``: 指定输出目录，默认为 \"output\"。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:70
msgid "``-p`` 或 ``--policy``: 指定输入事件生成策略，默认为 \"random\"。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:71
msgid "``-t`` 或 ``--timeout``: 指定超时时间（秒），默认为预设值。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:72
msgid "``-debug``: 开启调试模式，输出调试信息。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:73
msgid "``-keep_app``: 测试后保留设备上的应用。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:74
msgid "``-grant_perm``: 安装时授予所有权限，对 Android 6.0+ 有用。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:75
msgid "``-is_emulator``: 声明目标设备为模拟器。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:76
msgid "``-is_harmonyos``: 使用 HarmonyOS 设备。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:77
msgid "``-load_config``: 从 ``config.yml`` 加载参数，命令行参数将被忽略。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:80
msgid "YAML 配置文件"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:82
msgid "Kea 支持通过 YAML 配置文件（``config.yml``）来指定参数，以简化参数的配置过程。YAML 文件中的参数值将覆盖命令行参数。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:91
msgid "参数对象"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:93
msgid "Kea 使用 `dataclass` 定义了一个名为 `Setting` 的参数对象，用于存储和传递参数。这个对象包含了所有与测试相关的配置。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:96
msgid "启动 Kea"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:98
msgid "以下是 Kea 启动流程的简要说明："
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:100
msgid "解析命令行参数和 YAML 配置文件。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:101
msgid "设置参数对象 `Setting`。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:102
msgid "根据目标平台加载相应的 PDL 驱动。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:103
msgid "创建 Kea 实例并加载应用性质。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:104
msgid "启动 Kea 进行测试。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:107
msgid "主要函数设计"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:109
msgid "以下是 Kea CLI 中每个主要函数的功能介绍："
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:115
msgid "`parse_args` 函数："
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:112
msgid "负责解析命令行输入的参数。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:113
msgid "根据用户输入设置相应的命令行参数，并处理 `-load_config` 选项以决定是否从 YAML 配置文件中加载参数。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:115
#: ../source/part-designDocument/user-interface/cli/cli.rst:137
#: ../source/part-designDocument/user-interface/cli/cli.rst:156
#: ../source/part-designDocument/user-interface/cli/cli.rst:173
#: ../source/part-designDocument/user-interface/cli/cli.rst:195
#: ../source/part-designDocument/user-interface/cli/cli.rst:211
#: ../source/part-designDocument/user-interface/cli/cli.rst:226
msgid "其简化代码如下："
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:137
msgid "`load_yaml_args` 函数："
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:134
msgid "负责从 `config.yml` YAML 配置文件中读取参数。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:135
msgid "将配置文件中的参数值应用到参数对象中，覆盖命令行输入的参数。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:156
msgid "`sanitize_args` 函数："
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:153
msgid "对解析后的参数进行清洗和验证。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:154
msgid "确保所有参数在传递给 Kea 之前都是有效和一致的。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:173
msgid "`Setting` 数据类："
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:170
msgid "定义了 Kea 运行所需的配置参数的数据结构。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:171
msgid "存储和管理如 APK 路径、设备序列号、输出目录等参数。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:195
msgid "`load_pdl_driver` 函数："
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:192
msgid "根据目标平台（Android 或 HarmonyOS）加载相应的 PDL 驱动。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:193
msgid "确保 Kea 能够与目标设备的操作系统交互。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:211
msgid "`start_kea` 函数："
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:208
msgid "初始化 DroidBot 实例，并设置 Kea 的 PDL 驱动。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:209
msgid "创建 Kea 实例，加载应用性质，并开始执行测试。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:226
msgid "`main` 函数："
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:223
msgid "作为程序的入口点，串联起整个 Kea 启动流程。"
msgstr ""

#: ../source/part-designDocument/user-interface/cli/cli.rst:224
msgid "调用其他函数完成参数解析、配置加载、PDL 驱动加载和 Kea 启动。"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/decorators.rst:2
msgid "性质装饰器"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/decorators.rst:4
msgid "本部分旨在解释 Kea 的性质定义装饰器是如何设计及实现的。"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/decorators.rst:9
msgid ""
"在KeaTest中，使用装饰器定义性质。装饰器的作用是对函数本身进行修改。在Kea中，用户的初始化、前置条件、主路径函数都是一个函数， "
"我们使用装饰器获取函数体，并对这个函数体进行标记。由于python中函数为一等对象，我们使用装饰器获取函数体后可以动态地往这个函数对象中 "
"设置属性，我们根据不同的装饰器，设置不同的MARKER属性标记。在Kea加载性质的时候，我们读取如下的数据结构， "
"并将如下的数据结构通过KeaTestElements类进行读取，并转换为方便Kea读取和处理的数据结构：KeaTestElements。"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/decorators.rst:21
msgid "从用户自定义KeaTest到运行时KeaTestElements的转换"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/decorators.rst:24
msgid "性质的定义"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/decorators.rst:26
msgid "下述的@rule和@precondition装饰器将用户定义的一条性质封装在数据结构Rule中，并对这个性质的函数进行使用RULE_MARKER进行标记。"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/decorators.rst:28
msgid ""
"以下是Rule数据数据结构的定义。precondition用于存放一个函数对象，存储一个计算前置条件的函数。function用于存储这条性质的交互场景(interaction"
" scenario)。"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/decorators.rst:41
msgid "@rule装饰器用于定义一条性质。其中，RULE_MARKER为一个常量。"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/decorators.rst:44
msgid "``f: Callable[[Any], None]`` : 一个交互场景函数对象"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/decorators.rst:47
msgid "``Callable[[Any], None]`` : 被RULE_MARKER标记后已解析Rule的函数对象"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/decorators.rst:65
msgid ""
"@precondition前提条件指定了性质何时可以被执行。一个性质可以有多个前提条件，每个前提条件由 `@precondition` "
"指定。其中， PRECONDITIONS_MARKER为一个常量。"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/decorators.rst:69
msgid "``precond: Callable[[Any], bool]`` : 一个返回布尔值的已经被@rule装饰过的函数对象"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/decorators.rst:72
msgid "``Callable[[Any], bool]`` : 被RULE_MARKER标记后已解析前置条件的函数"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/decorators.rst:96
msgid "初始化函数的定义"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/decorators.rst:98
msgid ""
"@initializer定义一个初始化函数，用于应用的初始化，如跳过新手教程等。 "
"下述的@initializer装饰器将用户定义的一条性质封装在数据结构Initializer中，并对这个性质的函数进行使用INITIALIZER_MARKER进行标记。"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/decorators.rst:101
msgid "以下是Initializer数据结构的定义。function用于存放一个函数对象，为初始化时要执行的一系列操作。"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/decorators.rst:110
msgid "@initializer装饰器用于定义一个初始化函数，其中，INITIALIZER_MARKER是一个常量。"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/decorators.rst:113
msgid "``f: Callable[[Any], None]`` : 定义了初始化事件的初始化函数对象"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/decorators.rst:116
msgid "``Callable[[Any], None]`` : 被INITIALIZER_MARKER标记的初始化函数对象"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/decorators.rst:132
msgid "主路径函数的定义"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/decorators.rst:134
msgid ""
"主路径指定了一系列事件，从应用起始页执行这些事件会将应用引到至性质的起始状态（满足前置条件的页面）。 "
"下述的@mainPath装饰器将用户定义的一条性质封装在数据结构MainPath中，并对这个性质的函数进行使用MAINPATH_MARKER进行标记。"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/decorators.rst:137
msgid ""
"以下是MainPath数据结构的定义。function用于存放用户定义的mainPath函数对象，path为对这个函数进行源代码处理后获取的详细路径步骤，"
" 为一个存储了主路径中各个步骤的源代码的列表。"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/decorators.rst:152
msgid "@mainPath装饰器将用户定义的一条性质封装在数据结构MainPath中，其中，MAINPATH_MARKER是一个常量。"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/decorators.rst:155
msgid "``f: Callable[[Any], None]`` : 定义了主路径事件的函数对象"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/decorators.rst:158
msgid "``Callable[[Any], None]`` : 被MAINPATH_MARKER标记的初始化函数对象"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/kea-test.rst:2
msgid "KeaTest"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/kea-test.rst:4
msgid "本部分旨在解释 Kea 的性质定义类 KeaTest 是如何设计及实现的。"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/kea-test.rst:9
msgid "KeaTest 是提供给用户编写性质的测试类。继承 KeaTest 就创建了一个测试样例。"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/kea-test.rst:11
msgid ""
"在继承的 KeaTest 子类中，我们编写对应的函数，并通过装饰器的方式定义性质中的初始化函数(Initializer)、 "
"前置条件(Precodition)、交互场景(Rule)和主路径函数(MainPath)。"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/kea-test.rst:14
msgid ""
"KeaTest 是一个空类，本质上是为用户提供了一个容器，Kea会在此容器中寻找用户自定义的性质，并将其加载入 Kea 中。在实现层面， 用户继承"
" KeaTest 编写自己的性质。而 Kea 通过识别并载入 KeaTest 的子类以实现读取用户的性质。"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/pdl_driver.rst:2
msgid "PDL 驱动"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/pdl_driver.rst:4
msgid "本部分旨在解释 Kea 的性质定义语言驱动 PDL 是如何设计及实现的。"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/pdl_driver.rst:7
msgid "PDL 驱动的功能设计"
msgstr "Design of PDL Driver"

#: ../source/part-designDocument/user-interface/keaTest-suite/pdl_driver.rst:9
msgid ""
"PDL 驱动是在基于性质的测试中，用户与设备在执行性质时与设备交互的驱动。 PDL 驱动有安卓设备的 PDL "
"驱动（基于uiautomator2），鸿蒙设备的 PDL 驱动（基于hmdriver2）"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/pdl_driver.rst:14
msgid "PDL 驱动设计参考了 uiautomator2 和 hmdriver2"
msgstr "The design of PDL refers to uiautomator2 and hmdriver2"

#: ../source/part-designDocument/user-interface/keaTest-suite/pdl_driver.rst:16
msgid "uiautomator2: https://github.com/openatx/uiautomator2"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/pdl_driver.rst:18
msgid "hmdriver2: https://github.com/codematrixer/hmdriver2"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/pdl_driver.rst:20
msgid ""
"PDL驱动的使用语法是 ``d(Selector(**kwargs)).attr(args)`` 。其中 "
"``Selecotor(**kwargs)`` 是控件选择器， 控件选择器通过字典的方式指定控件的属性，如安卓中的 resourceId, "
"className，鸿蒙中的 id， bundlename等。attr 是对选定控件的操作，包括click、longClick等操作。 "
"``attr(args)`` 中的 ``args`` 为传入方法的参数。如在 ``input_text(\"Hello\")`` "
"中传入要输入的字符串 \"Hello\"。"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/pdl_driver.rst:25
msgid ""
"我们的PDL驱动实际上是kea与对应自动化测试工具(uiautomator2、hmdriver2)的中间层，语法与目标的测试工具一致， "
"主要用于做一些额外的操作，如保存当前事件、截图等，以方便kea访问到对应的操作数据，方便生成错误报告等。"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/pdl_driver.rst:29
msgid "安卓设备的 PDL 驱动的实现"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/pdl_driver.rst:31
msgid "安卓设备的PDL驱动通过uiautomator2实现。主要用于让用户编写的性质和应用进行交互。"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/pdl_driver.rst:33
msgid "安卓的PDL驱动继承于uiautomator2的Driver类，部分安卓PDL的python风格简化代码实现示意如下："
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/pdl_driver.rst:65
msgid "PDL的核心功能的解析如下："
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/pdl_driver.rst:94
msgid "鸿蒙设备的 PDL 驱动实现"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/pdl_driver.rst:96
msgid "鸿蒙设备的PDL驱动通过hmdriver2实现。主要用于让用户编写的性质和应用进行交互。"
msgstr ""

#: ../source/part-designDocument/user-interface/keaTest-suite/pdl_driver.rst:98
msgid "鸿蒙的PDL驱动继承于hmdriver2的Driver类，部分鸿蒙PDL的python风格简化代码实现示意如下："
msgstr ""

